// Copyright (c) 2023 - 2025 Chair for Design Automation, TUM
// Copyright (c) 2025 Munich Quantum Software Company GmbH
// All rights reserved.
//
// SPDX-License-Identifier: MIT
//
// Licensed under the MIT License

#include "mlir/Dialect/MQTOpt/IR/MQTOptStdOps.td"

Constraint ExtractCNotResults(op: Op<mqtopt.x>) -> (target: Value, control: Value) {
  return (op.0, op.1);
}

Constraint IsEmpty(valueRange: ValueRange) [{
  return mlir::success(valueRange.empty());
}];

Constraint HasTwoElements(valueRange: ValueRange) [{
  return mlir::success(valueRange.size() == 2);
}];

Rewrite BuildXOp(op: Op, target: Value, posControls: ValueRange, negControls: ValueRange) -> Op [{
  auto qubitType = target.getType();
  auto outType = llvm::SmallVector<mlir::Type>{1, qubitType};
  auto outPosCtrlType = llvm::SmallVector<mlir::Type>{posControls.size(), qubitType};
  auto outNegCtrlType = llvm::SmallVector<mlir::Type>{negControls.size(), qubitType};

  return rewriter.create<mqt::ir::opt::XOp>(op->getLoc(), outType, outPosCtrlType, outNegCtrlType, mlir::DenseF64ArrayAttr{}, mlir::DenseBoolArrayAttr{},
        mlir::ValueRange{}, llvm::SmallVector<mlir::Value>{target}, posControls, mlir::ValueRange{});
}];

Rewrite Self(op: Op) => op;

Rewrite First(valueRange: ValueRange) -> Value [{
  return valueRange[0];
}];

Rewrite Second(valueRange: ValueRange) -> Value [{
  return valueRange[1];
}];

Pattern SwapReconstructionAndElisionPattern with recursion {
  // match
  let root = op<mqtopt.x>(_: [ValueRange, IsEmpty], target: Value, control: Value, _: [ValueRange, IsEmpty]) { operandSegmentSizes = inSegmentSizes: Attr, resultSegmentSizes = outSegmentSizes: Attr };
  let rootOut = ExtractCNotResults(root);
  let secondCNot = op<mqtopt.x>(_: [ValueRange, IsEmpty], rootOut.control, rootOut.target, _: [ValueRange, IsEmpty]);

  // rewrite
  rewrite root with {
    replace secondCNot with (rootOut.control, rootOut.target);
    replace root with op<mqtopt.x>((), control, (target), ()) {operandSegmentSizes = inSegmentSizes, resultSegmentSizes = outSegmentSizes};
  };
}

Pattern ElidePermutationsPattern with recursion {
  // match
  let root = op<mqtopt.swap>(params: ValueRange, targets: ValueRange, posCtrls: ValueRange, negCtrls: ValueRange);
  IsEmpty(params);
  HasTwoElements(targets);
  IsEmpty(posCtrls);
  IsEmpty(negCtrls);

  // rewrite
  replace root with (Second(targets), First(targets));
}
