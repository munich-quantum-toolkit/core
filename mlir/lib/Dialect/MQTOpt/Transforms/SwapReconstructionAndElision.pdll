// Copyright (c) 2023 - 2025 Chair for Design Automation, TUM
// Copyright (c) 2025 Munich Quantum Software Company GmbH
// All rights reserved.
//
// SPDX-License-Identifier: MIT
//
// Licensed under the MIT License

#include "mlir/Dialect/MQTOpt/IR/MQTOptStdOps.td"

Constraint ExtractCNotResults(op: Op<mqtopt.x>) -> (target: Value, control: Value) {
  return (op.0, op.1);
}

Constraint IsEmpty(valueRange: ValueRange) [{
  return mlir::success(valueRange.empty());
}];

Rewrite BuildXOp(op: Op, target: Value, posControls: ValueRange, negControls: ValueRange) -> Op [{
  auto qubitType = target.getType();
  auto outType = llvm::SmallVector<mlir::Type>{1, qubitType};
  auto outPosCtrlType = llvm::SmallVector<mlir::Type>{posControls.size(), qubitType};
  auto outNegCtrlType = llvm::SmallVector<mlir::Type>{negControls.size(), qubitType};

  return rewriter.create<mqt::ir::opt::XOp>(op->getLoc(), outType, outPosCtrlType, outNegCtrlType, mlir::DenseF64ArrayAttr{}, mlir::DenseBoolArrayAttr{},
        mlir::ValueRange{}, mlir::ValueRange{target}, posControls, mlir::ValueRange{});
}];

//Constraint twoValues(valueRange: ValueRange) -> (first: Value, second: Value) [{
Rewrite swapValues(valueRange: ValueRange) -> ValueRange [{
  if (valueRange.size() == 2) {
      //llvm::OwningArrayRef<mlir::Value> storage(valueRange.size());
      //llvm::copy(valueRange, storage.begin());
      //return storage;
    return llvm::OwningArrayRef<mlir::Value>{ valueRange[1], valueRange[0] };
  }
  return valueRange;
  //auto reversed = llvm::reverse(valueRange);
  //llvm::SmallVector<mlir::Value> result;
  //for (auto&& element : reversed) {
  //  result.push_back(element);
  //}
  //return result;
}];

//Pattern SwapReconstructionAndElisionPattern with recursion {
//  // match
//  let root = op<mqtopt.x>(_: [ValueRange, IsEmpty], target: Value, control: Value, _: [ValueRange, IsEmpty]);
//  let rootOut = ExtractCNotResults(root);
//  let secondCNot = op<mqtopt.x>(_: [ValueRange, IsEmpty], rootOut.control, rootOut.target, _: [ValueRange, IsEmpty]);
//
//  // rewrite
//  rewrite root with {
//    replace secondCNot with BuildXOp(secondCNot, control, (target), ());
//    //erase root;
//  };
//}

Pattern ElidePermutationsPattern with recursion {
  //let root = op<mqtopt.swap>(_: [ValueRange, IsEmpty], targets: ValueRange, _: [ValueRange, IsEmpty], _: [ValueRange, IsEmpty]);
  let root = op<mqtopt.swap>(params: ValueRange, targets: ValueRange, posCtrls: ValueRange, negCtrls: ValueRange);
  IsEmpty(params);
  IsEmpty(posCtrls);
  IsEmpty(negCtrls);

  replace root with swapValues(targets);
}
