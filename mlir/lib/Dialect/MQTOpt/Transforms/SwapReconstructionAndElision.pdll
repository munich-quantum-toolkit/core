// Copyright (c) 2023 - 2025 Chair for Design Automation, TUM
// Copyright (c) 2025 Munich Quantum Software Company GmbH
// All rights reserved.
//
// SPDX-License-Identifier: MIT
//
// Licensed under the MIT License

#include "mlir/Dialect/MQTOpt/IR/MQTOptStdOps.td"

Constraint IsEmpty(valueRange: ValueRange) [{
  return mlir::success(valueRange.empty());
}];

Rewrite First(valueRange: ValueRange) -> Value [{
  return valueRange[0];
}];

Rewrite Second(valueRange: ValueRange) -> Value [{
  return valueRange[1];
}];

Pattern ElidePermutationsPattern with recursion {
  replace op<mqtopt.swap>(_: ValueRange, targets: ValueRange, posCtrls: [ValueRange, IsEmpty], negCtrls: [ValueRange, IsEmpty])
  with (Second(targets), First(targets));
}

Pattern SwapReconstructionAndElisionPattern with recursion {
  // match
  let root = op<mqtopt.x>(_: ValueRange, target: Value, control: Value, _: [ValueRange, IsEmpty]);
  let secondCNot = op<mqtopt.x>(_: ValueRange, root.1, root.0, _: [ValueRange, IsEmpty]);

  // rewrite
  rewrite root with {
    replace secondCNot with (root.1, root.0);
    replace root with op<mqtopt.x>((), (control), (target), ()) {operandSegmentSizes = attr<"array<i32: 0, 1, 1, 0>">, resultSegmentSizes = attr<"array<i32: 1, 1, 0>">};
  };
}
